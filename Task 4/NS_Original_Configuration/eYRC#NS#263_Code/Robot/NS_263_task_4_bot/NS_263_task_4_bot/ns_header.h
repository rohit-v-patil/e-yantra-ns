/*
*
*Team Id: 0263
*Author List: Rohit Vasant Patil, Brijesh Kumar Patra, Kunal Kishore Sahu, Debasish Panigrahy
*Filename: ns_header.h
*Theme: Nutty Squirrel
*Functions: init_devices, print_sensor, read_line_sensor, print_line_sensor, rgb_port_config, color_sensor_pin_config,
*			color_sensor_pin_interrupt_init, color_sensor_scaling, filter_red, filter_green, filter_blue, red_read, green_read,
*			blue_read, color_sensor_scaling, check_color, buzzer_pin_config, buzzer_on, motion_pin_config, servo1_pin_config,
*			servo2_pin_config, lcd_pin_config, adc_pin_config, timer4_init, timer5_init, adc_init, ADC_Conversion, Sharp_GP2D12_estimation,
*			velocity, forward, stop, backward, left, right, soft_left, soft_right, servo_1, servo_2, servo_1_free, servo_2_free, servo_set_pos,
*			pick, place
*Global Variables: pulse, red, green, blue, ADC_Value, left_line_sensor, middle_line_sensor, right_line_sensor, sharp, dist
*
*/




#define THRESHOLD 0x16

volatile unsigned long int pulse = 0; // pulse: to store the number of pulses generated by the color sensor
volatile unsigned long int red;       // red: variable to store the pulses when red filter is selected
volatile unsigned long int blue;      // blue: variable to store the pulses when blue filter is selected
volatile unsigned long int green;     // green: variable to store the pulses when green filter is selected



unsigned char ADC_Value=0;
unsigned char left_line_sensor=0;
unsigned char middle_line_sensor=0;
unsigned char right_line_sensor=0;
unsigned char sharp=0;
unsigned int dist;

/*
* Function Name: forward_wls
* Input: node
* Output: void
* Logic: Uses white line sensors to go forward by the nodes specified
* Example Call: forward_wls(2) //Goes forward by two nodes
*
*/
void forward_wls(unsigned char node);


/*
*
* Function Name: left_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn left until black line is encountered
* Example Call: left_turn_wls(); //Turns right until black line is encountered
*
*/
void left_turn_wls(void);


/*
*
* Function Name: sharp_left_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn left until black line is encountered even if already on black line
* Example Call: sharp_left_turn_wls(); //Turns right until black line is encountered
*
*/
void sharp_left_turn_wls(void);


/*
*
* Function Name: right_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn right until black line is encountered
* Example Call: right_turn_wls(); //Turns right until black line is encountered
*/
void right_turn_wls(void);


/*
*
* Function Name: sharp_right_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn left until black line is encountered even if already on black line
* Example Call: sharp_right_turn_wls(); //Turns right until black line is encountered
*
*/
void sharp_right_turn_wls(void);


/*
*
* Function Name: read_line_sensor
* Input: void
* Output: void
* Logic: Reads values of all three(left, middle and right) line sensors and stores in variables left_line_sensor,middle_line_sensor,right_line_sensor respectively
* Example Call: read_line_sensors();
*
*/
void read_line_sensor(void);

/*
*
* Function Name: Task_4
* Input: void
* Output: void
* Logic: Use this function to encapsulate your Task 1.2 logic
* Example Call: Task_4();
*/
void Task_4(void);

/*
*
* Function Name: create_adjacency_matrix
* Input: void
* Output: void
* Logic: creates graph of arena
* Example Call: create_adjacency_matrix();
*
*/
void create_adjancey_matrix();

/*
*
* Function Name: breadth_first_search
* Input: int, int (source and destination node)
* Output: void
* Logic: uses breadth first search algorithm to find path between the given nodes and stores path in path[] array
* Example Call: breadth_first_search(source,dest)
*
*/
void breadth_first_search(int, int);

/*
*
* Function Name: travel_path
* Input: void
* Output: void
* Logic: this function specifies for each node that bot should turn in which direction based on the previous, current node and next node 
* Example Call: sharp_right_turn_wls(); //Turns right until black line is encountered
*
*/
void travel_path(void);

/*
*
* Function Name: check_object
* Input: void
* Output: int (1 if object is present in front else 0)
* Logic: uses front ir sensor to detect any object present in front
* Example Call: check_object();
*
*/
int check_object(void);

/*
*
* Function Name: check_color
* Input: void
* Output: void
* Logic: uses color sensor and predefined functions to store value of red,green and blue filters and stores in red, green and blue variables
* Example Call: sharp_right_turn_wls(); //Turns right until black line is encountered
*
*/
char check_color(void);

/*
*
* Function Name: check_nut
* Input: void
* Output: nut color
* Logic: adjusts bot in front of nut and checks color and returns it
* Example Call: check_nut()
*
*/
void check_nut(void);

void pick(void);

void place(void);



void buzzer_pin_config();
void color_sensor_pin_config();
void color_sensor_pin_interrupt_init();
void color_sensor_scaling();
void motion_pin_config();
void servo1_pin_config(); //Configure PORTH 3 pin for servo motor 1 operation
void servo2_pin_config(); //Configure PORTH 4 pin for servo motor 2 operation
void lcd_port_config();
void adc_pin_config();
void timer4_init();
void timer5_init();
void adc_init();
void lcd_init();
void servo_set_pos();
unsigned char ADC_Conversion(unsigned char);



/*
*
* Function Name: init_devices
* Input: void
* Output: void
* Logic: initializes all devices
* Example Call: init_devices();
*
*/
void init_devices(void)
{
	rgb_port_config();
	buzzer_pin_config();
	
	color_sensor_pin_config();
	color_sensor_pin_interrupt_init();
	color_sensor_scaling();
	
	motion_pin_config();
	servo1_pin_config(); 
	servo2_pin_config(); 
	
	lcd_port_config();
	adc_pin_config();
	
	timer4_init();
	timer5_init();
	
	adc_init();
	lcd_init();
	
	PORTB = PORTB | 0xFF;	//switch of led
	servo_set_pos();
}


/*
*
* Function Name: print_sensor
* Input: row & column of lcd and channel no
* Output: reads and prints value of White line sensor on lcd
* Logic: uses ADC_Conversion function to read value of White line sensor and prints on lcd using lcd_print function 
* Example Call: print_sensor();
*
*/
void print_sensor(char row, char column, unsigned char channel)
{
	ADC_Value=ADC_Conversion(channel);
	lcd_print(row,column,ADC_Value,3);
}

/*
*
* Function Name: read_line_sensor
* Input: void
* Output: reads value of White line sensor on lcd
* Logic: uses ADC_Conversion function to read value of White line sensor and store it in right_line_sensor, middle_line_sensor and left_line_sensor
* Example Call: read_line_sensor();
*
*/
void read_line_sensor()
{
	
	right_line_sensor = ADC_Conversion(1);
	middle_line_sensor = ADC_Conversion(2);
	left_line_sensor = ADC_Conversion(3);
}


/*
*
* Function Name: print_line_sensor
* Input: void
* Output: prints value of White line sensor on lcd
* Logic: prints values of right_line_sensor, middle_line_sensor and left_line_sensor on lcd
* Example Call: print_line_sensor();
*
*/
void print_line_sensor(void)
{
	/*print_sensor(2,1,3);	//Prints value of White Line Sensor1
	print_sensor(2,5,2);	//Prints Value of White Line Sensor2
	print_sensor(2,9,1);	//Prints Value of White Line Sensor3*/
	lcd_print(1,1,left_line_sensor,3);
	lcd_print(1,5,middle_line_sensor,3);
	lcd_print(1,9,right_line_sensor,3);
	lcd_print(2,7,dist,3);
}







/*
*Function Name: rgb_port_config
*Input: void
*Output: void
*Logic: defines output pins for RGB led on PORTH pins PB3, PB2, PB1
*       and makes all pins high to initially turn off the led
*Example Call: rgb_port_config()
*/
void rgb_port_config (void)
{
	DDRB = DDRB | 0x0F; 
	PORTB = PORTB | 0x0F; // initially all off
	/*
	PORTB = PORTB & 0xFD;//red
	PORTB = PORTB & 0xFB;//blue
	PORTB =PORTB & 0xF7;//green
	*/
}


/*
*Function Name: color_sensor_pin_config
*Input: void
*Output: void
*Logic:	sets PORTD pin 0 i.e. PD0/INT0(external interrupt pin 0) as input for color sensor
*		and PORTB pins PB4, PB5, PB6, PB7 as output pins for S0, S1, S2, S3 for selecting different color filters and output frequency scaling
*Example Call: color_sensor_pin_config()
*/
void color_sensor_pin_config(void)
{
	/*****************************************
	Define DDR and PORT values for the port on which Color sensor is connected
	******************************************/
	DDRD = DDRD & 0x00;
	DDRD = DDRD | 0xFE; //11111110 //Set the direction of PORTD pin 0 as input
	PORTD = PORTD | 0x01; //enable internal pull-up for PORTD 0 pin
	
	DDRB = DDRB | 0xF0;		//set PORTB PB4,PB5,PB6,PB7 as output for S0,S1,S2,S3 of color sensor respectively
	PORTB = PORTB & 0x00;	//initially all low
}


/*
*Function Name: color_sensor_pin_interrupt_init
*Input: void
*Output: void
*Logic: sets external interrupt 0 to trigger with falling edge
		by setting bit 0 of External Interrupt Control Register A(EICRA) as 0 and bit 1 of EICRA as 1  
*Example Call: color_sensor_pin_interrupt_init()
*/
void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt  
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
}

//ISR for color sensor

/*
*Function Name: ISR
*Input: INT0_vect
*Output: void
*Logic: This is the Interrupt Service Routine which increments pulse count by 1 each time it is called 
*Example Call: it is automatically called when an external interrupt is triggered on PD0/INT0
*/
ISR(INT0_vect) // Pass the timer number in place of n in INTn_vect
{
	//increment on receiving pulse from the color sensor
	pulse++;
}






/*
*Function Name: filter_red
*Input: void
*Output: void
*Logic: sets PB6 and PB7 to low for selecting red filter
*Example Call:filter_red()
*/
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	 PORTB = PORTB & 0xBF;//set S2 low
	 PORTB = PORTB & 0x7F;//set S3 low
}

/*
*Function Name: filter_green
*Input: void
*Output: void
*Logic: sets PB6 and PB7 to high for selecting green filter
*Example Call: filter_green()
*/
void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTB = PORTB | 0x40;//set S2 High
	PORTB = PORTB | 0x80;//set S3 High
}

/*
*Function Name: filter_blue
*Input: void
*Output: void
*Logic: sets PB6 to low and PB7 to high for selecting blue filter
*Example Call: filter_blue()
*/
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTB = PORTB & 0xBF;//set S2 low
	PORTB = PORTB | 0x80;//set S3 High
}

/*
*Function Name: filter_clear
*Input: void
*Output: void
*Logic: sets PB6 to high and PB7 to low for selecting clear filter
*Example Call: filter_clear()
*/
void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTB = PORTB | 0X40;//set S2 High
	PORTB = PORTB & 0x7F;//set S3 Low
}

//Color Sensing Scaling

/*
*Function Name: color_sensor_scaling
*Input: void
*Output: void
*Logic: sets PB4 and PB5 to high for output scaling 20%
*Example Call: color_sensor_scaling()
*/
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	
	PORTB = PORTB | 0x10;//set S0 high
	PORTB = PORTB | 0x20;//set S1 high
}

/*
*Function Name: red_read
*Input: void
*Output: void
*Logic: selects red filter using filter_red then captures pulses for 100ms and stores pulse count in variable red
*Example Call: red_read()
*/
void red_read(void)
{
	//Red
	filter_red(); //select red filter
	pulse = 0;//reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse; //store the count in variable called red
}

/*
*Function Name: green_read
*Input: void
*Output: void
*Logic: selects green filter using filter_green then captures pulses for 100ms and stores pulse count in variable green
*Example Call: green_read()
*/
void green_read(void) 
{
	//Green
	filter_green(); //select green filter
	pulse = 0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse; //store the count in variable called green
}

/*
*Function Name: blue_read
*Input: void
*Output: void
*Logic: selects blue filter using filter_blue then captures pulses for 100ms and stores pulse count in variable blue
*Example Call: blue_read()
*/
void blue_read(void)
{
	//Blue
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
}



/*
*Function Name: check_color
*Input: void
*Output: detects color and returns it and also glows corresponding led 
*Logic: compares pulse count of all three colors and returns color and 
*Example Call: check_color()
*/
char check_color()
{
	  int black_color_threshold = 1800;
	  
	  
	  red_read();	//read pulses after selecting red filter
	  _delay_ms(500);
	  green_read();	//read pulses after selecting green filter
	  _delay_ms(500);
	  blue_read();	//read pulses after selecting blue filter
	  _delay_ms(500);
	  
	  
	  //if all three pulse counts are less than the threshold value then color is black
	  if(red < black_color_threshold && green < black_color_threshold && blue < black_color_threshold)
	  {
		//black
		PORTB |= 0x0F; //making all bits high to turn off led
		return 'W';
	  }
	  else
	  {
		  //if red pulse count is greater than green and blue
		  if(red > green && red > blue)
		  {
			PORTB |= 0x0F;	//first making all bits high to turn off led
			PORTB &= 0xFD;	//making PB1 low for red color diode
			_delay_ms(2000);
			PORTB |= 0x0F;
			return 'R';
		  }
		  //if green pulse count is greater than red and blue
		  else if(green > blue && green > red)
		  {
			PORTB |= 0x0F;	//first making all bits high to turn off led
			PORTB &= 0xF7;	//making PB3 low for green color diode
			_delay_ms(2000);
			PORTB |= 0x0F;
			return 'G';
		  }
		  //if blue pulse count is greater than green and red
		  else if(blue > red && blue > green)
		  {
			PORTB |= 0x0F;	//first making all bits high to turn off led
			PORTB &= 0xFB;	//making PB2 low for blue color diode
			_delay_ms(2000);
			PORTB |= 0x0F;
			return 'B';
		  }
	  }
	  return 'W';
}


/*
*Function Name: buzzer_pin_config
*Input: void
*Output: void
*Logic: configure output pin for buzzer
*Example Call: blue_read()
*/
void buzzer_pin_config (void)
{
	DDRE  = DDRE | 0x10;  //making PORTE 4 pin output
	PORTE = PORTE | 0x00; //setting PORTE 4 pin to logic 0
}


/*
*Function Name: buzzer_on
*Input: void
*Output: makes buzzer sound for 3 seconds
*Logic: makes buzzer pin high for 3 seconds
*Example Call: buzzer_on()
*/
void buzzer_on()
{
	PORTE |= 0x10; 
	_delay_ms(3000);
	PORTE &= 0x00;
}







//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRA = 0x0F; //Output Port
	PORTA = 0x00; // Initially motor stop
	DDRL = 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
	PORTL = 0x00; //Initially low
}



//Configure PORTH 3 pin for servo motor 1 operation
void servo1_pin_config (void)
{
 DDRH  = DDRH | 0x08;  //making PORTH 3 pin output
 PORTH = PORTH | 0x08; //setting PORTH 3 pin to logic 1
}

//Configure PORTH 4 pin for servo motor 2 operation
void servo2_pin_config (void)
{
 DDRH  = DDRH | 0x10;  //making PORTH 4 pin output
 PORTH = PORTH | 0x10; //setting PORTH 4 pin to logic 1
}



void lcd_port_config(void)
{
	DDRC |= 0xFF;
	PORTC &= 0x80; 
}


void adc_pin_config(void)
{	
	DDRK = DDRK & 0x00;
	DDRF = DDRF & 0x00;
}




//TIMER4 initialization in 10 bit fast PWM mode  
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer4_init(void)
{
 TCCR4B = 0x00; //stop
 TCNT4H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
 TCNT4L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
 OCR4AH = 0x03;	//Output compare Register high value for servo 1
 OCR4AL = 0xFF;	//Output Compare Register low Value For servo 1
 OCR4BH = 0x03;	//Output compare Register high value for servo 2
 OCR4BL = 0xFF;	//Output Compare Register low Value For servo 2
 OCR4CH = 0x03;	//Output compare Register high value for servo 3
 OCR4CL = 0xFF;	//Output Compare Register low Value For servo 3
 ICR4H  = 0x03;	
 ICR4L  = 0xFF;
 TCCR4A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR4B for Selecting FAST PWM Mode*/
 TCCR4C = 0x00;
 TCCR4B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
}





// Timer 5 initialized in PWM mode for velocity control
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	//TCCR5B = 0x00;	//Stop
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT5L = 0x00;	//Counter lower 8-bit value to which OCR5xH value is compared with
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
	
}



void adc_init()
{
	/*ADMUX = (1<<REFS0) | (1 << ADLAR);
	ADCSRA = (1 << ADEN) | (1 << ADIE) | (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
	DIDR0 = (1 << ADC0D);*/
	
	ADCSRA = 0x00;
	ADCSRB = 0x00;
	ADMUX = 0x60;
	ADCSRA = 0x86;
	ACSR = 0x80;
	
}


unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
	{
		ADCSRB = 0x08;
	}
	Ch = Ch & 0x07;
	ADMUX= (ADMUX & 0xF8) | Ch;
	ADCSRA |= (1 << ADSC); 		//Set start conversion bit
	while((ADCSRA&0x10)==0); //Wait for ADC conversion to complete
	a=ADCH;
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
	ADCSRB = 0x00;
	return a;
}



// This Function calculates the actual distance in millimeters(mm) from the input
// analog value of Sharp Sensor. 
unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
	distanceInt = (int)distance;
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
}



void velocity (unsigned char left_motor, unsigned char right_motor)
{
OCR5AL = (unsigned char)left_motor;
OCR5BL = (unsigned char)right_motor;
}



void forward (void)
{
	PORTA = 0x06;
}

void stop (void)
{
	PORTA = 0x00;
}

void backward(void)
{
	PORTA = 0x09;
}

void soft_left(void)
{
	PORTA = 0x04;
}

void soft_right(void)
{
	PORTA = 0x02;
}

void left(void)
{
	PORTA = 0x05;
}

void right(void)
{
	PORTA = 0x0A;
}


//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR4AH = 0x00;
 OCR4AL = (unsigned char) PositionPanServo;
}



//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
 OCR4BH = 0x00;
 OCR4BL = (unsigned char) PositionTiltServo;
}


void servo_1_free (void) //makes servo 1 free rotating
{
 OCR4AH = 0x03; 
 OCR4AL = 0xFF; //Servo 1 off
}

void servo_2_free (void) //makes servo 2 free rotating
{
 OCR4BH = 0x03;
 OCR4BL = 0xFF; //Servo 2 off
}



/*
*Function Name: servo_set_pos
*Input: void
*Output: void
*Logic: sets initial servo position
*Example Call: servo_set_pos()
*/
void servo_set_pos(void)
{
	servo_1(155);
	_delay_ms(1000);
	servo_2(218);
	_delay_ms(1000);
	
	servo_1_free();
	servo_2_free();
}


/*
*Function Name: pick
*Input: void
*Output: picks up a nut
*Logic: moves arm down and grabs the nut and again moves up
*Example Call: pick()
*/
void pick(void)
{
		int i;
		
		//arm open
		for(i=218;i>=115;i--)
		{
			servo_2(i);
			_delay_ms(10);
		}
		
		servo_2_free();
		_delay_ms(500);
		
		//arm down
		for(i=170;i>=90;i--)
		{
			servo_1(i);
			_delay_ms(10);
		}
		servo_1_free();
		_delay_ms(500);
		
		//arm close
		for(i=115;i<=218;i++)
		{
			servo_2(i);
			_delay_ms(10);
		}
		//servo_2_free();
		_delay_ms(500);
		
		//arm up
		for(i=90;i<=170;i++)
		{
			servo_1(i);
			_delay_ms(10);
		}
		servo_1_free();
		servo_2_free();
}


/*
*Function Name: place
*Input: void
*Output: places a nut
*Logic: moves arm down and leaves the nut and again moves up
*Example Call: pick()
*/
void place(void)
{
		int i;
		//arm down
		for(i=170;i>=90;i--)
		{
			servo_1(i);
			_delay_ms(10);
		}
		servo_1_free();
		_delay_ms(500);
		
		//arm open
		for(i=218;i>=115;i--)
		{
			servo_2(i);
			_delay_ms(10);
		}
		servo_2_free();
		_delay_ms(500);
		
		//arm up
		for(i=90;i<=170;i++)
		{
			servo_1(i);
			_delay_ms(10);
		}
		servo_1_free();
		
			_delay_ms(500);
			
		//arm close
		for(i=115;i<=220;i++)
		{
			servo_2(i);
			_delay_ms(10);
		}
		servo_2_free();
		_delay_ms(500);
}

